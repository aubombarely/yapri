
package YapRI::Data::Matrix;

use strict;
use warnings;
use autodie;

use Carp qw| croak cluck |;
use YapRI::Base;


###############
### PERLDOC ###
###############

=head1 NAME

YapRI::Data::Matrix.pm
A module to build and pass to a command file a Matrix

=cut

our $VERSION = '0.01';
$VERSION = eval $VERSION;

=head1 SYNOPSIS

  use YapRI::Base;
  use YapRI::Data::Matrix;

  ## Constructors:

  my $rmatrix = YapRI::Data::Matrix->new('matrix1');
  
  ## Accessors:

  my $matrixname = $rmatrix->get_name();
  $rmatrix->set_name('matrix');

  my $coln = $rmatrix->get_coln();
  $rmatrix->set_coln(3);

  my $rown = $rmatrix->get_rown();
  $rmatrix->set_rown(4);

  my @data = $rmatrix->get_data();
  $rmatrix->set_data(\@data);

  my @colnames = $rmatrix->get_colnames();
  $rmatrix->set_colnames(\@colnames);

  my @rownames = $rmatrix->get_colanmes();
  $rmatrix->set_colnames(\@rownames);

  ## Adding/deleting/changing data:

  $rmatrix->add_coldata($col_y, [$y1, $y2, $y3, $y4]);
  $rmatrix->add_rowdata($row_x, [$x1, $x2, $x3]);
  
  $rmatrix->push_col([$yy1, $yy2, $yy3, $yy4]);
  $rmatrix->push_row([$xx1, $xx2, $xx3]);

  my @oldcol = $rmatrix->pop_col();
  my @oldrow = $rmatrix->pop_row();

  $rmatrix->change_col($col_x, $col_z);
  $rmatrix->change_col($col_x, $col_z);


  ## Parsers:

  $rmatrix->parse_resultfile({ file     => $filename, 
                               coln     => $x, 
                               rown     => $y, 
                               colnames => 1, 
                               rownames => 1,
                            });
     
  my $rbase = YapRI::Base->new();
  $rmatrix->pass_rbase($rbase);

   ## Slicers:

   my @col2 = $rmatrix->get_col($col_y);
   my @row3 = $rmatrix->get_row($row_x);
   my $elem2_3 = $rmatrix->get_element($row_x, $col_y);


=head1 DESCRIPTION

 This module pass perl variables to a YapRI::Data::Matrix object that convert
 them in a R command line that it is passed to YapRI::Base object as a block.

   +-----------+    +----------------------+    +------------+    +---+--------+
   | PerlData1 | => | YaRI::Data::Matrix 1 | => |            | => |   | Input  |
   +-----------+    +----------------------+    | YaRI::Base |    | R |--------+
   | PerlData2 | <= | YaRI::Data::Matrix 2 |<=  |            | <= |   | Output |
   +-----------+    +----------------------+    +------------+    +---+--------+


=head1 AUTHOR

Aureliano Bombarely <ab782@cornell.edu>


=head1 CLASS METHODS

The following class methods are implemented:

=cut 



############################
### GENERAL CONSTRUCTORS ###
############################

=head1 (*) CONSTRUCTORS:

=head2 ---------------


=head2 constructor new

  Usage: my $rmatrix = YapRI::Data::Matrix->new();

  Desc: Create a new YapRI::Data::Matrix object

  Ret: a YapRI::Data::Matrix object

  Args: A hash reference with the following parameters:
          name     => a scalar with the matrix name, 
          coln     => a scalar with the column number (int),
          rown     => a scalar with the row number (int),
          colnames => an array ref. with the column names,
          rownames => an array ref. with the row names,
          data     => an array ref. with the matrix data ordered by row.        
        
  Side_Effects: Die if the argument used is not a hash or its values arent 
                right.

  Example: my $rmatrix = YapRI::Data::Matrix->new(
                                     { 
                                       name     => 'matrix1',
                                       coln     => 3,
                                       rown     => 4,
                                       colnames => ['a', 'b', 'c'],
                                       rownames => ['W', 'X', 'Y', 'Z'],
                                       data     => [ 1, 1, 1, 2, 2, 2, 
                                                     3, 3, 3, 4, 4, 4,],
                                     }
                                   );

          
=cut

sub new {
    my $class = shift;
    my $args_href = shift;

    my $self = bless( {}, $class ); 

    my %permargs = (
	name     => '\w+',
	coln     => '^\d+$',
	rown     => '^\d+$',
        colnames => 'ARRAY',
        rownames => 'ARRAY',
        data     => 'ARRAY',
	);

    ## Check variables.

    my %args = ();
    if (defined $args_href) {
	unless (ref($args_href) eq 'HASH') {
	    croak("ARGUMENT ERROR: Arg. supplied to new() isnt HASHREF");
	}
	else {
	    %args = %{$args_href}
	}
    }

    foreach my $arg (keys %args) {
	unless (exists $permargs{$arg}) {
	    croak("ARGUMENT ERROR: $arg isnt permited arg for new() function");
	}
	else {
	    unless (defined $args{$arg}) {
		croak("ARGUMENT ERROR: value for $arg isnt defined for new()");
	    }
	    else {
		if (ref($permargs{$arg})) {
		    unless (ref($permargs{$arg}) eq ref($args{$arg})) {
			croak("ARGUMENT ERROR: $args{$arg} isnt permited val.");
		    }
		}
		else {
		    if ($args{$arg} !~ m/$permargs{$arg}/) {
			croak("ARGUMENT ERROR: $args{$arg} isnt permited val.");
		    }
		}
	    }
	}
    }

    
    return $self;
}



####
1; #
####
